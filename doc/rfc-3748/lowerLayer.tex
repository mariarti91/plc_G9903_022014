\section{Нижний уровень}

\subsection{Требования}

При использовании EAP предполагается что нижний уровень обладает следующими свойствами:

\begin{enumerate}
 \item Ненадежное соединение. В EAP аутентификатор продолжает отправку запроса пока не получит ответ, таким образом EAP не считает соединение надежным. Так, EAP определяет собственный механизм повторной отправки, можно (хотя не желательно) использовать механизм повторной отправки на нижнем уровне и уровне EAP одновременно когда EAP запускается поверх надежного соединения на нижнем уровне.

Необходимо помнить что Success и Failure пакеты не отправляются повторно. Без надежного нижнего уровня и с количеством ошибок сети которым нельзя пренебреч, пакеты могут потеряться из-за таймаутов. Поэтому желательно, что бы реализация была устойчива к патере Success и Failure пакетов, как это описанов в пункте 4.2.

 \item Детектирование ошибок нижнего уровня. Так как EAP считает что нижний уровень ненадежен, EAP полагается на обнаружение ошибок нижнего уровня (например CRC, контрольные суммы, MIC и т.д.). EAP метод можент не включать в себя MIC, или MIC может подсчитываться не для всх полей пакет, таких как поле Code, Identifier, Length or Type. В результате этого, без возможности обнаружения ошибок на нижнем уровне, акие ошибки будут проникать на уровень EAP или уровень методов EAP, что приведет кневозможности пройти аутентификацию.

Например EAP TLS (RFC2716) с подсчитыванием MIC только для поля Type-Data, считает ошибки MIC фатальными. Без возможности обнаружить ошибки на нижнем уровне данный метод (и все похожие) не будут являться надежными.

 \item Безопасность нижнего уровня. EAP не требует от нижнего уровня таких функций безопасности как конфиденциальность каждого пакета, аутентификации, целостности и защиты от повторов. Однако там, где эти функции доступны, могут быть использованы EAP методы, поддерживающие выработку динамической ключевой информации (Пункт 7.2.1). Благодаря этому есть возможность связать EAP аутентификацию последующих данных и предотвращение модификации, спуфинга или повторной отправки. Подробнее об этом в пункте 7.1.

 \item Минимальный MTU. EAP способен работать на нижнем уровне, предоставляющем размер MTU не менее 1020 октетов.

EAP не поддерживат определение путей MTU, фрагментацию и восстановление MTU EAP. Такой поддержки нет и у методов, описанных в данном стандарте.

Как правило пиры EAP получают информацию о EAP MTU от нижнего уровня и выставлят размер кадра EAP на основании этих данных. В случае если аутентификатор работает в сквозном режиме, аутентификатор не имеет возможности получить информацию о MTU напрямую и как следствие зависит от информации, передаваемой ему от аутнетификатора, такой как атрибуты Framed-MTU, описанной в RFC3579, секция 2.4.

Такие методы как EAP-TLS (RFC2716) поддерживают фрагментацию и восстановление, EAP методы, разработанные для использования с PPP, имеющие размер MTU в 1500 октетов, гарантирующих контроль кадров (описано в RFC1661, секция 6.1) могут не поддерживать фрагментацию и восстановление кадров.

EAP методы могут предполагать минимальный размер EAP MTU равным 1020 октетов при отсутствии инфомрации о MTU. EAP методы ДОЛЖНЫ включать поддержку фрагментации и восстановления пакетов если информация, которую они передают, может превышать размеры минимального EAP MTU.

EAP является жестко декларированным протоколом, ввиду чего он неэффективно работает при использовании механизмов фрагментации и восстановления пакетов. Таким образом, если нижний уровень поддерживает механизмы фрагментирования и восстановления пакетов (например если EAP работает над уровнем IP), то предпочтительнее оставить функции фрагментации и сстановления пакетов на нижнем уровне, а не выносить из на уровень EAP. Этого можно добиться путем искусственного увеличения EAP MTU, в результате таких действий эти функции будут переданы на нижний уровень.

\item Возможность дублирования. Если нижний уровень надежным, то EAP обеспечивается недублирующимся потоком данных. Но в требованиях к нижнему уровню нет требований о защите от дублирования. И пир, и аутентификатор могут определить дублирование пакетов по полю Identifier.

\item 

\end{enumerate}
